{% extends "base.html" %}

{% load rest_framework %}

{% block subtitle %}
    change spotter
{% endblock subtitle %}

{% block call_to_action %}
    <div id="callToAction">Please spot differences and draw polygons around them.</div>
{% endblock call_to_action %}

{% block head %}
    {% csrf_token %}
<link rel="stylesheet" href="https://js.arcgis.com/next/esri/themes/light/main.css">
<link rel="stylesheet" href="/static/MicroModal.css">
<script src="https://js.arcgis.com/next/"></script>
{% endblock head %}

{% block content %}
    <div class="left-title">{{ pair.old_image }}</div>
    <div class="right-title">{{ pair.new_image }}</div>
    <div id="left_mapview_container" ></div>
    <div id="right_mapview_container" ></div>


    <div class="modal micromodal-slide" id="annotation-notes-modal" aria-hidden="true">
        <div class="modal__overlay" tabindex="-1" data-micromodal-close>
            <div class="modal__container" role="dialog" aria-modal="true" aria-labelledby="modal-1-title">
                <header class="modal__header">
                    <h2 class="modal__title" id="modal-1-title">
                        Submit the change you found
                    </h2>
                    <button class="modal__close" aria-label="Close modal" data-micromodal-close></button>
                </header>
                <main class="modal__content" id="modal-1-content">
                    Thanks for drawing a polygon that you think represents a difference between the two images! Please 
                    add a little extra information here about what you saw.
                    <p>
                        <form id="annotation-notes-form">
                            {% render_form annotation_serializer %}
                        </form>
                    </p>
                </main>
                <footer class="modal__footer">
                    <button id="annotation-notes-submit" class="modal__btn modal__btn-primary">Submit</button>
                    <button id="annotation-notes-close" class="modal__btn" data-micromodal-close aria-label="Close this dialog window">Close</button>
                </footer>
            </div>
        </div>
    </div>
    
    <script type="text/javascript">

    const setupSideBySide = ()=>{
        require(["esri/Map",
            "esri/views/MapView",
            "esri/layers/ImageryTileLayer",
            "esri/views/draw/Draw",
            "esri/layers/GraphicsLayer",
            "esri/Graphic",
            "esri/widgets/Sketch",
            "https://unpkg.com/micromodal/dist/micromodal.min.js"
        ], function (
                Map, MapView, ImageryTileLayer, Draw, GraphicsLayer, Graphic, Sketch, MicroModal){
            MicroModal.init()

            const makeTileMap = (tile_url, container)=>{
                const webmap = new Map({});
                const locog = new ImageryTileLayer({
                    url: tile_url,
                })
                webmap.layers.add(locog);
                return new MapView({
                    container: container,
                    map: webmap,
                    constraints: {
                        snapToZoom: false
                    }
                })
            }

            const leftview = makeTileMap('{{ pair.old_image.file_data.url }}', 'left_mapview_container')
            leftview.crosshair = createPoint(0,0)
            leftview.graphics.add(leftview.crosshair)
            const rightview = makeTileMap('{{ pair.new_image.file_data.url }}', 'right_mapview_container')
            rightview.crosshair = createPoint(0,0)
            rightview.graphics.add(rightview.crosshair)
            const views = [leftview, rightview]
            let active = leftview
            
            
            // TODO move these functions into libraries
            const sync = (source) => {
                // Sets the center and zoom of all views to the center and zoom of source
                if (!active || !active.viewpoint || active !== source) {
                    return
                }

                for (const view of views) {
                    if (view !== source) {
                        view.viewpoint = source.viewpoint
                    }
                }
            }

            function createPoint(lat, lon) {
                const point = {
                    type: "point",
                    longitude: lon,
                    latitude: lat
                };

                // Create a symbol for drawing the point
                const markerSymbol = {
                    type: "simple-marker",
                    style: "cross"
                };

                // Create a graphic and add the geometry and symbol to it
                return new Graphic({
                    geometry: point,
                    symbol: markerSymbol
                });
            }
            
            const syncPointer = (evt) => {
                // Sets the center and zoom of all views to the center and zoom of source
                for (const view of views) {
                    const cursor_coord = view.toMap({x:evt.x, y:evt.y})
                    view.crosshair.geometry= {
                        type: 'point',
                        x: cursor_coord.longitude,
                        y: cursor_coord.latitude
                    }
                }
            }
            
            const submitAnnotationModal = async() => {
                return new Promise((resolve) => {
                    MicroModal.show('annotation-notes-modal')
                    document.querySelector('#annotation-notes-submit').addEventListener(
                        "click", ()=>{
                            MicroModal.close('annotation-notes-modal')
                            resolve()
                        })
                    }
                )
            }
            
            
            for (const view of views) {
                view.watch(["interacting", "animation"], () => {
                    active = view
                })

                view.watch("viewpoint", () => sync(view))
                view.on("pointer-move", syncPointer)
            }

            // Drawing stuff
            const annotationLayer = new GraphicsLayer()
            const annotationLayerCopy = new GraphicsLayer()
            leftview.map.layers.add(annotationLayer)
            rightview.map.layers.add(annotationLayerCopy)
            const sketch = new Sketch({
                layer: annotationLayer,
                view: leftview,
                availableCreateTools: ["polygon"]
            });
            sketch.create("polygon")
            sketch.visible = false
            annotationLayer.graphics.on('after-add', async (evt) => {
                const wkt_srid = evt.item.geometry.spatialReference.wkid
                const wkt_points = evt.item.geometry.rings[0].map(pt=>`${pt[0]} ${pt[1]}`).toString()
                const wkt_geometry = `SRID=${wkt_srid};POLYGON ((${wkt_points}))`
                annotationLayerCopy.graphics.add(evt.item.clone())
                await submitAnnotationModal().then(()=>{
                    const annotationData = new FormData(document.querySelector("#annotation-notes-form"));
                    annotationData.append('csrfmiddlewaretoken',document.querySelector('[name=csrfmiddlewaretoken]').value)
                    annotationData.append('shape',wkt_geometry)
                    fetch('{% url 'annotation-list' %}', {
                        method: 'POST',
                        credentials: 'same-origin',
                        body: annotationData
                    })
                },  ()=>{
                        console.log("not submitted")
                    }
                    

                ) //TODO handle errors

            })
            leftview.ui.add(sketch, "top-right")
        })
    }
    const urlParams = new URLSearchParams(window.location.search)
    if (urlParams.get('comparer')==='blink') {
        console.log("Blink / fade mode not yet implemented")
    } else {
        // assuming we're in side-by-side mode
        setupSideBySide()
    }
    </script>
{% endblock content %}
